# Based Emoji

## Task

- Category: Van Halen Radiation Belt
- Points: 128
- Solves: 28

Description:

> ğŸ« 
>
> ğŸ•³
>
> ğŸ’»ğŸ˜€
>
> ğŸ§®ğŸ˜¥
>
> ğŸ‡¾ ğŸ‡´ ğŸ‡º â¬› ğŸ‡² ğŸ‡® ğŸ‡¬ ğŸ‡­ ğŸ‡¹ â¬› ğŸ‡¼ ğŸ‡¦ ğŸ‡³ ğŸ‡¹ â¬› ğŸ‡¹ ğŸ‡´ â¬› ğŸ‡º ğŸ‡¸ ğŸ‡ª â¬› ğŸ‡¦ â¬› ğŸ‡¹ ğŸ‡ª ğŸ‡· ğŸ‡² ğŸ‡® ğŸ‡³ ğŸ‡¦ ğŸ‡± â¬› ğŸ‡¹ ğŸ‡­ ğŸ‡¦ ğŸ‡¹ â¬› ğŸ‡­ ğŸ‡¦ ğŸ‡¸ â¬› ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡® ğŸ‡¸
>
> ğŸ‘ ğŸ†— ğŸŒˆ ğŸ’–

Upon connecting to the challenge and providing our ticket we are greeted with this rather cursed challenge:

```
â— â— â—   ğŸ‡¹ ğŸ‡­ ğŸ‡® ğŸ‡¸   ğŸ‡® ğŸ‡¸   ğŸ‡¦   ğŸ‡¹ ğŸ‡ª ğŸ‡¸ ğŸ‡¹   ğŸ‡´ ğŸ‡«   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®   ğŸ‡§ ğŸ‡· ğŸ‡´ ğŸ‡¦ ğŸ‡© ğŸ‡¨ ğŸ‡¦ ğŸ‡¸ ğŸ‡¹   ğŸ‡¸ ğŸ‡¾ ğŸ‡¸ ğŸ‡¹ ğŸ‡ª ğŸ‡²   â— â— â— 
ğŸ‡¼ ğŸ‡ª   ğŸ‡¦ ğŸ‡· ğŸ‡ª   ğŸ‡º ğŸ‡¸ ğŸ‡® ğŸ‡³ ğŸ‡¬   ğŸ‡§ ğŸ‡¦ ğŸ‡¸ ğŸ‡ª â– 3âƒ£ 2âƒ£   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®   ğŸ‡ª ğŸ‡³ ğŸ‡¨ ğŸ‡´ ğŸ‡© ğŸ‡® ğŸ‡³ ğŸ‡¬ 
ğŸ‡¹ ğŸ‡­ ğŸ‡¦ ğŸ‡¹   ğŸ‡² ğŸ‡ª ğŸ‡¦ ğŸ‡³ ğŸ‡¸   ğŸ‡ª ğŸ‡¦ ğŸ‡¨ ğŸ‡­   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡®   ğŸ‡· ğŸ‡ª ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡ª ğŸ‡³ ğŸ‡¹ ğŸ‡¸   5âƒ£   ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸ 
ğŸ‡§ ğŸ‡ª ğŸ‡± ğŸ‡´ ğŸ‡¼   ğŸ‡® ğŸ‡¸   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡® ğŸ‡³ ğŸ‡« ğŸ‡´ ğŸ‡· ğŸ‡² ğŸ‡¦ ğŸ‡¹ ğŸ‡® ğŸ‡´ ğŸ‡³   ğŸ‡³ ğŸ‡ª ğŸ‡ª ğŸ‡© ğŸ‡ª ğŸ‡©   ğŸ‡¹ ğŸ‡´   ğŸ‡¸ ğŸ‡´ ğŸ‡± ğŸ‡» ğŸ‡ª   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡¨ ğŸ‡­ ğŸ‡¦ ğŸ‡± ğŸ‡± ğŸ‡ª ğŸ‡³ ğŸ‡¬ ğŸ‡ª  
ğŸ‡³   ğŸŸ°   ğŸ“¡ğŸ¤¯ğŸ‰ğŸ¤ŸğŸŒ›ğŸ‘„ğŸŒğŸš€ğŸ§¨ğŸ¤ŸğŸ‰ğŸ¥µğŸŒŸğŸ’¾ğŸš€ğŸ§‚ğŸŒğŸ—¿ğŸ™ŒğŸŒğŸš€ğŸŒ›ğŸš€ğŸ§ ğŸ›¸ğŸ’µğŸŒğŸ¥ƒğŸ›°ğŸ”¥ğŸ”¥ğŸŒğŸ¤ŸğŸ’µğŸ‰ğŸ¦ğŸ’½ğŸ‘½ğŸ‘„ğŸŒğŸ§¨ğŸ’¥ğŸ‘„ğŸ‘½ğŸ’¥ğŸ“¼ğŸ¥µğŸ™ŒğŸ¦ğŸ“¼ğŸ§‚ğŸŒğŸ›¸ğŸ§ ğŸŒğŸ“¼ğŸ§ ğŸ¥ƒğŸ‘„ğŸ¤¯ğŸ›°ğŸ¤¯ğŸ’½ğŸ§‚ğŸŒğŸŒğŸ¦ğŸ‘„ğŸ§‚ğŸ‘½ğŸ’µğŸ’½ğŸŒğŸ”¥ğŸŒŸğŸ’¥ğŸŒğŸ’¾ğŸ’µğŸ’¥ğŸŒğŸ§‚ğŸŒğŸŒŸğŸ§‚ğŸŒğŸ‘„ğŸ§ ğŸ§‚ğŸ§ ğŸ›°ğŸŒğŸ“¼ğŸ‘€ğŸŒ›ğŸ›¸ğŸŒğŸ›°ğŸ”¥ğŸ“¡ğŸ“¡ğŸ§¨ğŸ›°ğŸ›°ğŸ›°ğŸ¤ŸğŸ‘½ğŸ’¥ğŸ›°ğŸ¥ƒğŸ¦ğŸŒğŸ’½ğŸŒğŸŒğŸ’¾ğŸ—¿ğŸ’¯ğŸ¤¯ğŸ’µğŸ§ ğŸ—¿ğŸŒğŸ¥µğŸ›°ğŸŒğŸ”¥ğŸŒğŸ§‚ğŸ§¨ğŸ‰ğŸš€ğŸ‘„ğŸ›¸ğŸ¤¯ğŸ¤¯ğŸ¤ŸğŸ‰ğŸ›°ğŸŒğŸŒğŸ’µğŸŒğŸ‘„ğŸŒŸğŸŒğŸ’½ğŸŒğŸ’µğŸ“¡ğŸŒ›ğŸ¤¯ğŸ›¸ğŸ“¼ğŸ’¯ğŸ“¼ğŸ§‚ğŸ‰ğŸ›°ğŸ¥µğŸ§¨ğŸ‘„ğŸ’µğŸŒğŸŒŸğŸ’©ğŸ¤ŸğŸ™ŒğŸ›°ğŸ‘½ğŸ§¨ğŸ¥µğŸš€ğŸ§‚ğŸŒ›ğŸ¥ƒğŸŒğŸ—¿ğŸ¥µğŸŒğŸ’¥ğŸ¥µğŸ“¡ğŸ™ŒğŸŒğŸ¤ŸğŸ’½ğŸ‘½ğŸ§ ğŸ§‚ğŸ™ŒğŸ’µğŸŒğŸŒ›ğŸ’½ğŸŒ›ğŸŒğŸ§¨ğŸŒğŸ‰ğŸš€ğŸ¦ğŸ’½ğŸ’½ğŸš€ğŸ¦ğŸ›¸ğŸ§‚ğŸ¤¯ğŸ‰ğŸ’½ğŸ’µğŸ¤ŸğŸ‘„ğŸ’¥ğŸš€ğŸ¦ğŸ’¯ğŸ‰ğŸ‰ğŸ’¾ğŸŒğŸ“¼ğŸ‘„ğŸŒğŸ’½ğŸ‘½ğŸ§ ğŸ¤¯ğŸ‘€ğŸ“¡ğŸ¥µğŸ’©ğŸ”¥ğŸŒ›ğŸ¥µğŸ§ ğŸ’½ğŸš€ğŸ¤¯ğŸ™ŒğŸ“¼ğŸ’¥ğŸš€ğŸ§¨ğŸŒğŸ¤¯ğŸ¥µğŸ’©ğŸ›°ğŸ¦ğŸŒŸğŸ“¡ğŸŒğŸ‘½ğŸ¥µğŸ—¿ğŸ›°ğŸ“¡ğŸ’½ğŸ§ ğŸ’¾ğŸŒğŸŒ›ğŸ¥ƒğŸ‘½ğŸ“¼ğŸ›¸ğŸ’µğŸ’½ğŸ›¸ğŸ—¿ğŸ“¼ğŸ‘„ğŸ§ ğŸ™ŒğŸ’¾ğŸ¤¯ğŸ‰ğŸ“¡ğŸ’¯ğŸ‰ğŸ‰ğŸŒğŸ§ ğŸ¤ŸğŸ’½ğŸ§‚ğŸŒğŸŒŸğŸ¦ğŸŒ›ğŸ’¾ğŸ¥ƒğŸ™ŒğŸ§‚ğŸ¤¯ğŸ›¸ğŸ™ŒğŸ§¨ğŸ¤ŸğŸ‰ğŸŒ›ğŸ¥ƒğŸ¦ğŸ’µğŸ¦ğŸŒğŸ›°ğŸŒŸğŸ”¥ğŸ‘„ğŸ¥µğŸ’µğŸ“¼ğŸŒğŸ›°ğŸ’¾ğŸ“¡ğŸŒŸğŸ¥ƒğŸŒğŸ’¥ğŸ§¨ğŸ¤¯ğŸ‘„ğŸ’½ğŸ§‚ğŸ¦ğŸŒğŸŒŸğŸ“¼ğŸ’¯ğŸŒğŸ’µğŸŒŸğŸš€ğŸŒğŸ¥ƒğŸ“¼ğŸ§‚ğŸ’¾ğŸ‰ğŸ¤ŸğŸ¤ŸğŸ›°ğŸŒ›ğŸ›¸ğŸ›°ğŸ‘€ğŸŒ›ğŸ§¨ğŸ“¡ğŸ“¼ğŸŒ›ğŸ’¾ğŸ“¼ğŸ§¨ğŸ‰ğŸ’¯ğŸ§¨ğŸŒğŸ’©ğŸ“¡ğŸ‘€ğŸ’¥ğŸ§ ğŸ’¾ğŸ‰ğŸŒğŸ“¡ğŸŒğŸŒğŸ‰ğŸ‘„ğŸ›°ğŸ‘½ğŸ’¥ğŸŒğŸ’µğŸŒğŸ›¸ğŸ¥ƒğŸŒğŸ’½ğŸ›¸ğŸ’¯ğŸ‘½ğŸ”¥ğŸ’¥ğŸŒğŸ™ŒğŸ¥ƒğŸŒ›ğŸŒğŸ¥ƒğŸ‘½ğŸ›°ğŸ›¸ğŸŒğŸŒŸğŸ’©ğŸ¤¯ğŸ¤¯ğŸ¥ƒğŸ§‚ğŸ¤ŸğŸ¤¯ğŸ‰ğŸ‘„
ğŸ‡ª   ğŸŸ°   ğŸ¥ƒğŸ‰ğŸ‰ğŸ›°

ğŸ‡­ ğŸ‡ª ğŸ‡· ğŸ‡ª   ğŸ‡¦ ğŸ‡· ğŸ‡ª   ğŸ‡¦   ğŸ‡« ğŸ‡ª ğŸ‡¼   ğŸ†“ ğŸğŸğŸ  ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¾ ğŸ‡´ ğŸ‡º   ğŸ‡¸ ğŸ‡¹ ğŸ‡¦ ğŸ‡· ğŸ‡¹ ğŸ‡ª ğŸ‡©
0âƒ£   ğŸŸ°   ğŸ‰
1âƒ£   ğŸŸ°   ğŸ›°
2âƒ£   ğŸŸ°   ğŸ¥ƒ
ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸš©  ğŸ‡¾ ğŸ‡´ ğŸ‡º   ğŸ‡² ğŸ‡º ğŸ‡¸ ğŸ‡¹   ğŸ‡© ğŸ‡ª ğŸ‡¨ ğŸ‡· ğŸ‡¾ ğŸ‡µ ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸš©
ğŸ” ğŸš© ğŸ‘‡
ğŸ‡¨   ğŸŸ°   ğŸ¥ƒğŸ¥µğŸ¥ƒğŸ“¡ğŸ’¾ğŸ™ŒğŸ’µğŸŒğŸ™ŒğŸš€ğŸ§ ğŸ’¾ğŸ’½ğŸ‘„ğŸ›¸ğŸš€ğŸ™ŒğŸ’¾ğŸ”¥ğŸ¥µğŸ’¥ğŸ›°ğŸ‘€ğŸ¥µğŸŒğŸ§ ğŸ‘½ğŸ›¸ğŸ›¸ğŸŒ›ğŸ›°ğŸ‘„ğŸ™ŒğŸ“¼ğŸ’µğŸŒğŸ™ŒğŸŒğŸ’¥ğŸ’¥ğŸ“¼ğŸ¤¯ğŸ’¯ğŸ¤ŸğŸ’¥ğŸ”¥ğŸ§‚ğŸ“¼ğŸ›¸ğŸ’¯ğŸ‘½ğŸŒğŸ‘€ğŸŒğŸ™ŒğŸŒŸğŸ“¡ğŸ‘€ğŸ—¿ğŸ’¥ğŸŒğŸš€ğŸ“¼ğŸŒŸğŸ¦ğŸ¦ğŸ›¸ğŸ‘½ğŸ§‚ğŸ¥µğŸ’¾ğŸ§ ğŸ§ ğŸ‘½ğŸ¤ŸğŸ›¸ğŸ‰ğŸ¥ƒğŸ™ŒğŸ›°ğŸ“¡ğŸ¤ŸğŸ’µğŸ‘€ğŸ¦ğŸ”¥ğŸ‘½ğŸŒğŸ›°ğŸ§ ğŸ—¿ğŸ§ ğŸ’¾ğŸŒ›ğŸŒğŸ§‚ğŸ“¡ğŸŒğŸ’¾ğŸ”¥ğŸ‰ğŸ¦ğŸ”¥ğŸ¤ŸğŸ“¼ğŸ’¯ğŸŒğŸ¤¯ğŸ‰ğŸ’¥ğŸŒ›ğŸŒğŸ›°ğŸ’¯ğŸ‰ğŸ‘„ğŸ§ ğŸŒğŸ‘½ğŸ™ŒğŸ§ ğŸ§‚ğŸ¦ğŸ§‚ğŸ’½ğŸ“¼ğŸ‰ğŸŒğŸ¥ƒğŸ’¾ğŸ‘„ğŸŒğŸ‰ğŸ“¡ğŸŒŸğŸ›¸ğŸ¤¯ğŸ’µğŸŒğŸ’¾ğŸš€ğŸŒŸğŸŒ›ğŸ›¸ğŸ§ ğŸ’µğŸ‘€ğŸŒğŸ¤ŸğŸŒ›ğŸŒ›ğŸŒğŸ‘„ğŸ’©ğŸŒŸğŸ¤ŸğŸŒğŸ¦ğŸ¤ŸğŸ™ŒğŸ’¯ğŸ‘€ğŸ¥ƒğŸŒğŸ”¥ğŸ’¯ğŸ’¾ğŸ”¥ğŸ’¥ğŸ”¥ğŸ‰ğŸš€ğŸŒŸğŸŒğŸ™ŒğŸŒğŸ¤ŸğŸ™ŒğŸŒğŸ“¡ğŸ‘½ğŸ§ ğŸ¦ğŸ’©ğŸ¥µğŸ‘€ğŸ‰ğŸ¥ƒğŸŒŸğŸ¤¯ğŸ’¯ğŸ¥ƒğŸ‰ğŸ§¨ğŸ¤¯ğŸ—¿ğŸ‘½ğŸ§¨ğŸ›°ğŸ“¼ğŸ›¸ğŸ§‚ğŸ’µğŸ¤ŸğŸ“¡ğŸŒğŸ“¡ğŸ‘„ğŸŒğŸ™ŒğŸŒğŸ’½ğŸ¥ƒğŸŒğŸŒğŸ§‚ğŸŒŸğŸ—¿ğŸ’¾ğŸ’¯ğŸŒğŸ‘€ğŸŒğŸ”¥ğŸ‘„ğŸ™ŒğŸ’¾ğŸ§ ğŸ’¥ğŸ’½ğŸ§¨ğŸ‰ğŸ—¿ğŸŒ›ğŸ’¾ğŸŒ›ğŸ‘½ğŸ›°ğŸ¥ƒğŸ§¨ğŸ¤ŸğŸŒğŸ¥µğŸŒğŸ¤ŸğŸ‰ğŸ“¼ğŸŒğŸ‘½ğŸ‘€ğŸ’¯ğŸ¦ğŸ¤ŸğŸ§¨ğŸ§¨ğŸ‘½ğŸ¥ƒğŸŒğŸŒŸğŸ“¼ğŸ‘½ğŸŒğŸŒğŸ§ ğŸ’¥ğŸ”¥ğŸ”¥ğŸ¥ƒğŸ¥ƒğŸ“¡ğŸ“¼ğŸ’µğŸ§ ğŸŒŸğŸ¥ƒğŸŒ›ğŸ“¡ğŸ’¾ğŸŒğŸ’¥ğŸ™ŒğŸ’¥ğŸ‘„ğŸ’¯ğŸ§¨ğŸ’½ğŸš€ğŸ“¡ğŸ¥ƒğŸ¥µğŸ’½ğŸ“¼ğŸ’½ğŸ—¿ğŸ—¿ğŸŒğŸ—¿ğŸ‘„ğŸ‘½ğŸŒğŸ‘½ğŸ¤¯ğŸ™ŒğŸ¥µğŸ§ ğŸ’¥ğŸŒ›ğŸŒğŸ¦ğŸŒ›ğŸ›¸ğŸ™ŒğŸ’¾ğŸ›¸ğŸ—¿ğŸ’¥ğŸ‘„ğŸ‘„ğŸŒğŸ”¥ğŸ‘„ğŸ“¡ğŸ¥ƒğŸŒğŸ§‚ğŸ¤¯ğŸ¤ŸğŸ’½ğŸš€ğŸ™ŒğŸ›¸ğŸ“¡ğŸ§¨ğŸ¥µğŸ›¸ğŸ’¾ğŸ›¸ğŸŒ›ğŸ‰ğŸ§¨ğŸš€ğŸŒğŸ’µğŸ’¥ğŸ”¥ğŸ’¥ğŸ’µğŸ“¡ğŸŒğŸŒğŸ¤ŸğŸ¥µğŸŒğŸ’¯ğŸ’µğŸ§‚ğŸ§ ğŸŒŸğŸ”¥ğŸ‰ğŸ“¡ğŸ‘„ğŸ¤ŸğŸŒ›ğŸ“¼ğŸ›°ğŸŒ›ğŸ§‚ğŸ™ŒğŸš€ğŸŒğŸ™ŒğŸ¥ƒğŸŒğŸ’©ğŸ¥µğŸ—¿ğŸŒğŸ›¸ğŸŒğŸ¦ğŸ™ŒğŸ‰ğŸ”¥ğŸ’¯ğŸŒğŸ‘€ğŸ’¾ğŸ¥µğŸŒğŸ¦ğŸŒğŸ›°ğŸŒğŸŒğŸ¦ğŸ’¯ğŸ¥ƒğŸŒğŸ‘½ğŸŒğŸ¦ğŸ§ ğŸ‘„ğŸ¥ƒğŸŒ›ğŸ’µğŸ’µğŸ’¾ğŸ¤¯
ğŸ‡² ğŸ‡ª ğŸ‡³ ğŸ‡º 
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   1âƒ£   ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡« ğŸ‡¦ ğŸ‡¨ ğŸ‡¹ ğŸ‡´ ğŸ‡· ğŸ‡¸   ğŸ‡´ ğŸ‡«   ğŸ‡¦ ğŸ‡³   ğŸ‡ª ğŸ‡² ğŸ‡´ ğŸ‡¯ ğŸ‡® 
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   2âƒ£   ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¦   ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   ğŸ‡µ ğŸ‡· ğŸ‡® ğŸ‡² ğŸ‡ª   ğŸ‡§ ğŸ‡¾   ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   3âƒ£   ğŸ‡¹ ğŸ‡´   ğŸ‡¬ ğŸ‡ª ğŸ‡¹   ğŸ‡¹ ğŸ‡­ ğŸ‡ª   ğŸ‡« ğŸ‡¦ ğŸ‡¨ ğŸ‡¹ ğŸ‡´ ğŸ‡· ğŸ‡¸   ğŸ‡´ ğŸ‡«   ğŸ‡¦   ğŸ‡· ğŸ‡¦ ğŸ‡³ ğŸ‡© ğŸ‡´ ğŸ‡²   ğŸ‡³ ğŸ‡º ğŸ‡² ğŸ‡§ ğŸ‡ª ğŸ‡·   ğŸ‡¹ ğŸ‡­ ğŸ‡¦ ğŸ‡¹   ğŸ‡® ğŸ‡¸   ğŸ‡¦ ğŸ‡¹   ğŸ‡´ ğŸ‡» ğŸ‡ª ğŸ‡·   5âƒ£   ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸   ğŸ‡® ğŸ‡³   ğŸ‡¸ ğŸ‡® ğŸ‡¿ ğŸ‡ª 
ğŸ‡µ ğŸ‡· ğŸ‡ª ğŸ‡¸ ğŸ‡¸   ğŸ‡¦ ğŸ‡³ ğŸ‡¾ ğŸ‡¹ ğŸ‡­ ğŸ‡® ğŸ‡³ ğŸ‡¬   ğŸ‡ª ğŸ‡± ğŸ‡¸ ğŸ‡ª   ğŸ‡¹ ğŸ‡´   ğŸ‡ª ğŸ‡½ ğŸ‡® ğŸ‡¹ 
```

## Solution

The challenge consists of reversing the base32 encoding. We can do so by utilising the three options giving to us below.

### Inherent constraints

The easiest way to solve this is using z3 as we found, in order to do so we need to build as many constraints as we can, so even before having a look at the functions we can add constraints for all emojis to encode unique numbers in `base32` (5 bits).

```python
io, n, e, c = connect()
emojis = set(n)
z3Vars = {x: z3.BitVec(x, 5) for x in emojis}
assert (len(z3Vars) == 32)

s = z3.Solver()

# Known values
for k, v in cachedMappings.items():
    s.add(z3Vars[k] == v)

# All are known to be different
for k1, v1 in z3Vars.items():
    for k2, v2 in z3Vars.items():
        if k1 == k2:
            continue
        s.add(v1 != v2)
```

### Factors

Using the first provided method we can easily get all the factors and add constraints for them:

```python
def get_factors(io, emoji):
    io.sendlineafter("ğŸ‡ª ğŸ‡½ ğŸ‡® ğŸ‡¹".encode("UTF-8"), "1âƒ£".encode("UTF-8"))
    io.sendlineafter("ğŸ‡« ğŸ‡¦ ğŸ‡¨ ğŸ‡¹ ğŸ‡´ ğŸ‡· ğŸ‡¸   ğŸ‡´ ğŸ‡« â“".encode(
        "UTF-8"), emoji.encode("UTF-8"))
    io.recvline()
    return io.recvline().strip().decode("UTF-8").split("  ")

# Collect all factors
for k, v in z3Vars.items():
    if k == ZERO:
        continue

    if k in cachedFactors:
        f = cachedFactors[k]
    else:
        f = get_factors(io, k)
        cachedFactors[k] = f
        print(f"Factors ({len(cachedFactors)}/31): {k} => {f}")

    # Factor contraints
    for x in f:
        s.add(z3.URem(v, z3Vars[x]) == 0)
```

### Primes

The second method can be utilised to obtain a list of all primes, this in turn can be used to add contraints restricting the n-bit primes to a specific set of numbers, as we know all n-bit primes.

```python
def get_prime(io, bits):
    io.sendlineafter("ğŸ‡ª ğŸ‡½ ğŸ‡® ğŸ‡¹".encode("UTF-8"), "2âƒ£".encode("UTF-8"))
    io.sendlineafter("ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸ â“".encode("UTF-8"),
                     str(bits).encode("UTF-8") + b"\xe2\x83\xa3")
    return io.recvline_contains("ğŸŸ°".encode("UTF-8")).strip().decode(
        "UTF-8").split("ğŸŸ°")[1].lstrip()

# Find all primes
for i in range(2, 6):
    hits = cachedPrimeHits[i] if i in cachedPrimeHits else set()
    while len(hits) < len(primes[i]):
        prime = get_prime(io, i)
        if prime in hits:
            continue

        hits.add(prime)
        print(f"{i}-bit prime ({len(hits)}/{len(primes[i])}): {prime}")
        s.add(z3.Or([z3Vars[prime] == x for x in primes[i]]))
```

### Primes, again..

Getting the model count for this unfortunately still yields loads of results. Luckily for us there is still a third method, which allows us to get the factors of a random n-bit number, whereas `6 <= n <= 9`. This can be used to build a multitude of constraints, such as more factorisation based ones etc, but an easy one is just finding new primes.

```python
def get_rand_factors(io, bits):
    io.sendlineafter("ğŸ‡ª ğŸ‡½ ğŸ‡® ğŸ‡¹".encode("UTF-8"), "3âƒ£".encode("UTF-8"))
    io.sendlineafter("ğŸ‡§ ğŸ‡® ğŸ‡¹ ğŸ‡¸ â“".encode("UTF-8"),
                     str(bits).encode("UTF-8") + b"\xe2\x83\xa3")
    io.recvline()
    return io.recvline().strip().decode("UTF-8").split("  ")

# Grab top bits of numbers and primes >5 bit
hits = set()
limit = 100
for i in range(6, 10):
    primeHits = cachedPrimeHits[i] if i in cachedPrimeHits else set()
    while len(hits) < (2 ** (i - 5)) - 1:
        f = get_rand_factors(io, i)
        if len(f) == 2:
            for x in f:
                if x == ONE:
                    continue

                cVar = z3.Concat(*[z3Vars[y] for y in x])
                if x in primeHits:
                    continue

                primeHits.add(x)
                print(
                    f"{i}-bit prime ({len(primeHits)}/{len(primes[i])}): {cVar}")
                s.add(z3.Or(*[cVar == x for x in primes[i]]))

                try:
                    models = get_all_models(s, limit)
                    print("Possible solutions: ", len(models))
                    if len(models) == 1:
                        break
                except:
                    print(f"Possible solutions: >{limit}")

        for x in f:
            if len(x) != 2:
                continue

            x = x[0]
            if x in hits:
                continue

            hits.add(x)
            print(f"{i - 5}-bit int ({len(hits)}/{(2 ** (i - 5)) - 1}): {x}")
            s.add(z3.ULT(z3Vars[x], 2**(i - 5)))
            s.add(z3.UGE(z3Vars[x], 2**(i - 6)))
    else:
        if len(primeHits) > len(cachedPrimeHits.get(i, [])):
            print(f"cachedPrimeHits[{i}] = ", end="")
            pprint(primeHits)
        
        continue
    break
```

### Decrypting the flag

Turns out the above methods result in only one viable model, so now we're able to decode anything encoded using _emoji_-`base32`.
What really threw us of here was that the flag was labelled as `c`, which is commonly used for the _ciphertext_ in `RSA` and `N` didn't seem to be weak at all. After some toying around we finally tried decrypting using `e` and it turned out the flag was actually **signed** using the private key, **not encrypted**.

```python
def decrypt_with_model(emojis, vars, model, n, e, c):
    mapping = {k: model[vars[k]].as_long() for k in emojis}
    n = parse_with_mapping(n, mapping)
    e = parse_with_mapping(e, mapping)
    c = parse_with_mapping(c, mapping)
    return long_to_bytes(pow(c, e, n))[::-1]
```

```
Flag: flag{hotel475384oscar4:GLI7XUJ06xDF8ebbGFiZi5jmfuDVjK02ME07iN-p7Ms3W39eQssXC370rd0imSQKf3HWRWuwjfabRflrS29Y_WQ}
```
